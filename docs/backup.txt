from _config import CLIENT_NU, SECRET_NU, UPDATE_NU, WEBHOOK_NU, ACCOUNTID_NU, FINALFILENAME_NU
import requests
from datetime import datetime
from calendar import monthrange
import json
import re
from os import remove, system, name
from os.path import exists
import csv
from time import sleep

#################### SETUP ####################

# Limpar console e apagar JSON e CSV (e utils)
def start(bank):
    print(f"################ IMPORTAÇÃO AUTOMÁTICA - FASE I ################")
    print(f"Alvo atual: {bank}")
    print(f"Alvo final: FireflyIII(DI)")
    print(f"################################################################")
    spacingConsole()
def cleanGenerated(filepath):
    if exists(filepath):
        remove(filepath)
        print(f"Antigo {filepath} apagado.")
    else:
        print(f"Arquivo '{filepath}' não existe.")
def cleanConsole():
    system('cls' if name == 'nt' else 'clear')
def spacingConsole():
    print("\n")
def waitFor(minutes):
    print(f"Esperando por {minutes} minutos para atualizar o banco de dados...")
    print(f"Futuramente implementarei um webhook para a espera não ser fixa.\n")
    minutes = minutes*60
    sleep(minutes)
    minutes = minutes/60
    print(f"Esperou por {minutes} minutos.{LINEBREAK}")
LINEBREAK = "\n"

def startJob(bankName, twoLettersBankName, client, secret, update, accountId):
cleanConsole()
start(bankname)
cleanGenerated(f"jsonBase_{twoLettersBankName}.json")
cleanGenerated(f"jsonTratado_{twoLettersBankName}.json")
cleanGenerated(f"resultado_{twoLettersBankName}.csv")
spacingConsole()

# Gerar a APIKEY e o TOKEN
urlAuth = "https://api.pluggy.ai/auth"

payloadAuth = {
    "clientId": f"{CLIENT_NU}",
    "clientSecret": f"{SECRET_NU}"
}
headersAuth = {
    "accept": "application/json",
    "content-type": "application/json"
}

responseAuth = requests.post(urlAuth, json=payloadAuth, headers=headersAuth)
dataAuth = responseAuth.json()
APIKEY = dataAuth["apiKey"]

urlConnector = "https://api.pluggy.ai/connect_token"

headersConnector = {
    "accept": "application/json",
    "content-type": "application/json",
    "X-API-KEY": f"{APIKEY}"
}

responseConnector = requests.post(urlConnector, headers=headersConnector)
dataConnector = responseConnector.json()
TOKEN = dataConnector["accessToken"]
#################################################################################
urlupdate = f"https://api.pluggy.ai/items/{UPDATE_NU}"

payloadUpdate = { "clientUserId": f"{CLIENT_NU}"}#, "webhookUrl": f"{WEBHOOK_NU}"}
headersUpdate = {
    "accept": "application/json",
    "content-type": "application/json",
    "X-API-KEY": f"{APIKEY}"
}

responseUpdate = requests.patch(urlupdate, json=payloadUpdate, headers=headersUpdate)
print("Atualizando extrato...")
print(f"Resposta: {responseUpdate}{LINEBREAK}")
waitFor(10)

#################### RETRIEVE ####################

# Pegar data atual (ano, mês e dia) + último dia do mês atual + utils
dateNow = datetime.now()
c_year = dateNow.year
c_month = dateNow.month
c_day = dateNow.day
l_day = monthrange(c_year, c_month)[1]
pageSize=500 # Max 500
FIRST_DAY = 1
LAST_DAY = l_day
IGNORADOS = 0

##### DEBUG #####
# DEBUG = 8
# dateStartDebug=f"{c_year}-{DEBUG:02d}-{FIRST_DAY:02d}"
# dateEndDebug=f"{c_year}-{DEBUG:02d}-{LAST_DAY:02d}"
# url = f"https://api.pluggy.ai/transactions?accountId={ACCOUNTID_NU}&ids=&from={dateStartDebug}&to={dateEndDebug}&pageSize={pageSize}"
##### DEBUG #####

dateStart=f"{c_year}-{c_month:02d}-{FIRST_DAY:02d}"
dateEnd=f"{c_year}-{c_month:02d}-{LAST_DAY:02d}"
print("Procurando pelo extrato...")
print(f"Data Inicial: {dateStart}")
print(f"Data Final: {dateEnd}")
spacingConsole()
url = f"https://api.pluggy.ai/transactions?accountId={ACCOUNTID_NU}&ids=&from={dateStart}&to={dateEnd}&pageSize={pageSize}"
#print(f"{url}")
#print(f"{dataAuth}")
#print(f"{responseConnector.text}")

headers = {
    "accept": "application/json",
    "X-API-KEY": f"{APIKEY}"
}

response = requests.get(url, headers=headers)
print("Extrato encontrado, convertendo...")

if response.status_code == 200:
    dados_json = response.json()

    # Nome do arquivo com data e hora para não sobrescrever
    nome_arquivo = f"jsonBase.json"

    with open(nome_arquivo, 'w', encoding='utf-8') as f:
        json.dump(dados_json, f, indent=2, ensure_ascii=False)

    print("Convertido com sucesso.")
    spacingConsole()
    print(f"JSON inicial salvo em: {nome_arquivo}")
else:
    print(f"Erro na requisição: {response.status_code}")
    print(response.text)

## Lógica de paginação se passar de 500 (checar se tem page2... até a falha?)
## Criptomoedas (eu poderia traçar uma API pra acompanhar? Ou iria me entegar?)

#################### GENERATE ####################

def carregar_json(caminho_arquivo):
    with open(caminho_arquivo, 'r', encoding='utf-8') as f:
        return json.load(f)

def salvar_json(dados, caminho_saida):
    with open(caminho_saida, 'w', encoding='utf-8') as f:
        json.dump(dados, f, indent=2, ensure_ascii=False)


## 7 virou 13 porque só consigo colocar assets accounts + No-networth, mas queria usar expenses
## mesma coisa com 6 que virou 12
def salvar_como_csv(lista_dicionarios, caminho_csv):
    """Salva uma lista de dicionários como um arquivo CSV, mesmo que os dicionários tenham chaves diferentes."""
    if not lista_dicionarios:
        print("Nenhuma transação para salvar em CSV.")
        return

    # Junta todos os campos únicos presentes em qualquer dicionário
    todas_colunas = set()
    for item in lista_dicionarios:
        todas_colunas.update(item.keys())

    colunas = sorted(todas_colunas)  # ordenado só pra consistência

    with open(caminho_csv, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=colunas, extrasaction='ignore')
        writer.writeheader()
        writer.writerows(lista_dicionarios)

    print(f"CSV salvo em: {caminho_csv}")

def processar_transacoes(transacoes):
    def capitalizar_nome(texto):
        def formatar_palavra(palavra):
            if palavra.upper() == "RDB":
                return "RDB"
            return palavra.capitalize()
        return ' '.join([formatar_palavra(p) for p in texto.split()])

    transacoes_tratadas = []

    for transacao in transacoes:
        descricao_original = transacao.get("description", "")
        descricao_raw = transacao.get("descriptionRaw", "")
        tipo_operacao = transacao.get("operationType", "")
        categoria = transacao.get("category", "")
        tipo_transacao = transacao.get("type", "")

        # === Documentos (pagador e recebedor) ===
        receiver = transacao.get("receiver", {})
        payer = transacao.get("paymentData", {}).get("payer") or {}
        receiver_doc = receiver.get("documentNumber", {}).get("value", "") or ""
        payer_doc = payer.get("documentNumber", {}).get("value", "") or ""

        cpf_receiver = receiver_doc.replace(".", "").replace("-", "").strip()
        cpf_payer = payer_doc.replace(".", "").replace("-", "").strip()

        nova_transacao = {
            "id": transacao["id"],
            "data": transacao["date"][:10],
            "quantia": transacao["amount"],
            "moeda": transacao["currencyCode"],
            "categoria": categoria
        }

        desc_lower = descricao_original.lower()
        termos_ignorados = [
            "pix no crédito"
            #"valor adicionado na conta por cartão de crédito"
        ]

        if any(t in desc_lower for t in termos_ignorados):
            global IGNORADOS
            IGNORADOS = IGNORADOS + 1
            continue

        # ======== Regras específicas (pagador, recebedor, direcao) ========
        if "transferência recebida" in desc_lower and cpf_receiver == "47925767847" and cpf_payer == "47925767847":
            nova_transacao["pagador"] = 12
            nova_transacao["recebedor"] = 1
            nova_transacao["direcao"] = "recebida"

        elif "transferência recebida" in desc_lower and cpf_receiver == "47925767847":
            nova_transacao["pagador"] = 12
            nova_transacao["recebedor"] = 1
            nova_transacao["direcao"] = "recebida"

        elif "transferência enviada" in desc_lower:
            nova_transacao["pagador"] = 1
            nova_transacao["recebedor"] = 14
            nova_transacao["direcao"] = "enviada"

        elif "transferência recebida" in desc_lower:
            nova_transacao["pagador"] = 12
            nova_transacao["recebedor"] = 1
            nova_transacao["direcao"] = "recebida"
        
        elif categoria.lower() == "same person transfer":
            # Fallback caso não tenha conseguido identificar
            nova_transacao["pagador"] = 12
            nova_transacao["recebedor"] = 1
            nova_transacao["direcao"] = "recebida"

        elif "aplicação rdb" in desc_lower:
            nova_transacao["pagador"] = 1
            nova_transacao["recebedor"] = 4
            nova_transacao["direcao"] = "enviada"

        elif "resgate rdb" in desc_lower:
            nova_transacao["pagador"] = 4
            nova_transacao["recebedor"] = 1
            nova_transacao["direcao"] = "recebida"

        elif "recarga de celular" in desc_lower:
            nova_transacao["pagador"] = 1
            nova_transacao["recebedor"] = 14
            nova_transacao["direcao"] = "enviada"

        elif "valor adicionado na conta por cartão de crédito" in desc_lower:
            nova_transacao["recebedor"] = 1
            nova_transacao["direcao"] = "recebida"

        elif "pagamento de fatura" in desc_lower:
            nova_transacao["pagador"] = 1
            nova_transacao["recebedor"] = 13
            nova_transacao["direcao"] = "enviada"

        elif "pagamento efetuado" in desc_lower:
            nova_transacao["pagador"] = 1
            nova_transacao["recebedor"] = 13
            nova_transacao["direcao"] = "enviada"

        else:
            # fallback com base no amount
            if transacao["amount"] < 0:
                nova_transacao["pagador"] = 1
                nova_transacao["direcao"] = "enviada"
            else:
                nova_transacao["recebedor"] = 1
                nova_transacao["direcao"] = "recebida"

        # ======== tipoDetalhado (type + operationType) ========
        tipo = tipo_transacao.strip().upper()
        operacao = tipo_operacao.strip().upper()
        if operacao:
            nova_transacao["tipoDetalhado"] = f"{tipo}, {operacao}"
        else:
            nova_transacao["tipoDetalhado"] = tipo

        # ======== nota (description capitalizada com espaçamento no "|") ========
        nota_raw = descricao_original or ""
        nota_tratada = nota_raw.replace("|", " | ")
        nota_final = capitalizar_nome(nota_tratada.strip())
        nova_transacao["nota"] = nota_final

        # ======== descricao (tratada, sem type ou operationType) ========
        nome_pos_pipe = ""
        if "|" in descricao_original:
            nome_pos_pipe = descricao_original.split("|", 1)[1].strip()
        elif "|" in descricao_raw:
            nome_pos_pipe = descricao_raw.split("|", 1)[1].strip()

        if "aplicação rdb" in desc_lower:
            nova_transacao["descricao"] = "Aplicação RDB"
        elif "resgate rdb" in desc_lower:
            nova_transacao["descricao"] = "Resgate RDB"
        elif nome_pos_pipe:
            nome_capitalizado = capitalizar_nome(nome_pos_pipe)
            nova_transacao["descricao"] = nome_capitalizado
        elif descricao_original.strip():
            nova_transacao["descricao"] = capitalizar_nome(descricao_original.strip())
        else:
            nova_transacao["descricao"] = "Descrição não disponível"

        transacoes_tratadas.append(nova_transacao)

    return transacoes_tratadas

def tratarDados(caminho_entrada, caminho_saida):
    json_original = carregar_json(caminho_entrada)
    transacoes = json_original.get("results", [])
    transacoes_tratadas = processar_transacoes(transacoes)
    salvar_json(transacoes_tratadas, caminho_saida)
    print(f"JSON tratado salvo em: {caminho_saida} (Registros ignorados por invalidez: {IGNORADOS})")
    salvar_como_csv(transacoes_tratadas, f"{FINALFILENAME_NU}")
    spacingConsole()

tratarDados("jsonBase.json", "jsonTratado.json")
